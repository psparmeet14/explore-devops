# 📚 Kubernetes Theory Notes

---

## 🚀 What is Kubernetes?

- Open-source container orchestration tool.
- Originally developed by Google.
- Helps manage containerized applications across various environments:
  - Physical machines
  - Virtual Machines (VMs)
  - Cloud environments
  - Hybrid environments

---

## ⭐ Key Features

- **High Availability**: No downtime.
- **Scalability**: High performance at scale.
- **Disaster Recovery**: Backup and restore mechanisms.

---

## 🏗️ Kubernetes Architecture

A Kubernetes Cluster is composed of:

### 1. Master Node
- Runs critical Kubernetes processes:
  - **API Server**: The entry point for K8s clients (CLI, UI, API).
  - **Controller Manager**: Tracks cluster state and performs tasks like replication.
  - **Scheduler**: Determines which node a new Pod should run on.
- Runs multiple master processes but requires fewer resources.
- It's essential to back up the master node — in production, usually two or more master nodes are maintained.

### 2. Worker Nodes
- Perform actual application workloads.
- Each node runs:
  - **Kubelet**: Primary node agent, allows cluster communication and task execution.
- Each worker node hosts:
  - Containers of different applications.
  - Pods containing the applications.

### 3. etcd
- The backing store of Kubernetes.
- Stores the **current state** and configuration of the cluster.
- Facilitates backup and restore.

### 4. Virtual Network
- Enables communication between nodes (master and workers).
- Unifies all nodes into a single, powerful machine aggregating all resources.

> **Note:** A **Node** can be a virtual or physical machine.

---

## 🔍 Core Kubernetes Components

### - **Kubelet**
- Primary node agent that enables task execution on nodes.

### - **API Server**
- Acts as the cluster's front door for all administrative operations.

### - **Controller Manager**
- Monitors the state of the cluster.

### - **Scheduler**
- Responsible for pod placement based on workload and resource availability.

### - **etcd**
- Distributed key-value store containing cluster state and configurations.

### - **Virtual Network**
- Provides seamless communication within the cluster.

---

## 🧱 Basic Kubernetes Concepts

### Node
- A virtual or physical machine in the cluster.

### Cluster
- Group of nodes and a master node.
- Cloud examples:
  - AWS: EC2
  - Azure: Virtual Machines
  - Google Cloud: Compute Engine

### Pod
- **Smallest deployable unit** in Kubernetes.
- An abstraction over containers.
- Usually holds:
  - 1 main application container.
  - Optional helper/sidecar containers.
- Properties:
  - Each pod gets a unique IP.
  - IP changes on re-creation.
  - Ephemeral: Can terminate and recreate.
  - Multiple containers in a pod share resources and communicate via `localhost`.
  - Pods interact via **Services**.
  - Pods are labeled for categorization.

### Namespace
- Provides isolation within the cluster (e.g., Dev vs QA environments).

### Labels & Selectors
- Used to associate Pods with ReplicaSets, Services, etc.

### Annotations
- Store metadata about Pods.

### ReplicaSets
- Ensures a specified number of pods are running.
- Auto-scales up if pods are missing.
- Tied to a specific release version.

### Deployment
- Blueprint/template for creating and managing Pods.
- Preferred way to manage stateless applications.
- Supports **Rolling Updates** for zero-downtime deployments.
- For **stateful apps**, use **StatefulSet** instead of Deployment.

### Services
- Enable stable network interfaces for Pods:
  - Permanent IP with DNS name.
  - Lifecycle decoupled from Pods.
  - Supports internal and external traffic.
  - Acts as a **Load Balancer**.
  - Always available interface to applications.

### Ingress
- Manages external access to the cluster.
- Routes traffic to internal services.

### ConfigMap
- Stores **non-confidential** external configuration data.
- Usage:
  - As environment variables.
  - As property files connected to Pods.

### Secret
- Stores sensitive data (credentials, passwords).
- Stored in **Base64 encoded** format.
- Usage similar to ConfigMaps but for confidential data.

### Volumes (Data Storage)
- Provides persistent storage for Pods.
- Can be local or cloud-based.
- Example: DB Pod data persistence across restarts.

### StatefulSet
- Manages stateful applications like databases.
- Ensures proper replication and data consistency.
- More complex than Deployments.

### DaemonSet
- Ensures that a copy of a Pod runs on **every node**.

---

## 🗒️ Kubernetes Configuration Files

- Written in **YAML** format.
- Stored alongside code or in a Git repository.
- **3 main sections**:
  
### 1. `metadata`
- Contains the resource's name and labels.

### 2. `spec` (Specification)
- Contains component-specific configurations.
- Examples:
  - Deployment: `replicas`, `selector`, `template`
  - Service: `selector`, `ports`

### 3. `status`
- Auto-generated by Kubernetes.
- Reflects the desired vs actual state.
- Self-healing feature is driven by continuous state updates from **etcd**.

---

> ✅ This covers the foundational theory for understanding Kubernetes clusters, components, and configurations.

---

## 📄 Example of Kubernetes Deployment Configuration (YAML)

```yaml
apiVersion: apps/v1           # Specifies the API version of the Kubernetes object
kind: Deployment              # Declares that this resource is a Deployment
metadata:
  name: my-app                # Name of the deployment
  labels:                     # Labels to categorize and identify the resource
    app: my-app
spec:
  replicas: 2                 # Number of pod replicas to run (desired state)
  selector:                   # Selector to match pods controlled by this deployment
    matchLabels:
      app: my-app
  template:                   # Template for the pods created by this deployment
    metadata:
      labels:
        app: my-app           # Labels applied to the pod
    spec:
      containers:             # List of containers to run in the pod
        - name: my-app        # Name of the container
          image: my-image     # Docker image to use for the container
          env:                # Define environment variables inside the container
            - name: SOME_ENV
              value: $SOME_ENV  # Value is populated from the environment where the YAML is applied
          ports:
            - containerPort: 8080  # Exposes port 8080 inside the container
```

## 🗒️ Explanation of Key Sections:
- apiVersion: Indicates which version of the Kubernetes API you are using to create the object.
- kind: The type of Kubernetes object (e.g., Deployment, Service, Pod).
- metadata:
  - `name`: Unique identifier for the resource within the namespace.
  - `labels`: Key-value pairs for organizing and selecting resources.
- spec:
  - `replicas`: Number of pod instances to maintain.
  - `selector`: Matches pods based on their labels, ensuring the deployment manages the correct set of pods.
  - `template`: Defines the pod specifications:
      - metadata.labels: Pods must match these labels to be managed by the deployment.
      - spec.containers:
          - `name`: The container's name.
          - `image`: Container image to deploy.
          - `env`: Define environment variables for the application inside the container.
          - `ports.containerPort`: The port on which the application runs inside the container.

> ✅ **Tip**: The environment variable `$SOME_ENV` can be injected at deployment time by setting it in your CI/CD pipeline or via `kubectl` commands.

---

# 🛠️ Kubernetes Configuration Principles

---

## ✅ 1. Declarative Configuration

- Kubernetes follows a **declarative configuration model**.
- Instead of specifying step-by-step instructions, you **declare the desired state** of the system using YAML or JSON files.
- Example: You declare that there should be 3 replicas of a pod, Kubernetes ensures that 3 pods are running — **without you needing to specify how to create or manage them.**

---

## 🔄 2. "Is" == "Should Be"

- The goal of Kubernetes is to maintain the state where:
  
  **Actual State (Is)** ➡️ **Desired State (Should Be)**

- The desired state is defined in the configuration files (YAML/JSON).
- Kubernetes continuously works to ensure that the **current state matches the desired state**.

---

## 📡 3. Controller Manager Checks: Desired State == Actual State

- The **Controller Manager** is a core component of the Kubernetes Master Node.
- Its responsibility is to:
  - **Continuously monitor** the actual state of the cluster (from `etcd`).
  - Compare it against the desired state defined in your configuration.
  - If there's a mismatch (e.g., a pod crashes), the Controller Manager:
    - Automatically takes corrective action to reconcile the states.
    - Example: Restarting pods, rescheduling them, scaling up/down.

> ✅ This is the essence of **self-healing** in Kubernetes.

---

### 🔗 Reference
- [Kubernetes Official Documentation on Controllers](https://kubernetes.io/docs/concepts/architecture/controller/)

---

# ⚙️ Minikube & Kubectl Overview

---

## 🖥️ Minikube

- **Purpose:** Local/Test Kubernetes Cluster Setup
- **Type:** Open-source tool
- **Functionality:**
  - Sets up a **single-node Kubernetes cluster** on your local machine.
  - Both **Master processes** and **Worker Node processes** run on the same machine.
  - The node comes with **Docker pre-installed** to run containers.

> ✅ **Primary Responsibility:**  
Provide a lightweight, fully functional Kubernetes cluster for **local development, testing, and learning**.

---

## 🔧 Kubectl

- **Purpose:** Command-line tool for interacting with Kubernetes clusters.
- **Type:** CLI (Command Line Interface)
- **Functionality:**
  - Allows you to **create, inspect, manage, and delete Kubernetes resources** like Pods, Deployments, Services, etc.
  - Communicates with the **API Server** of the Kubernetes cluster.

Example usage:
- `kubectl get pods` — List all pods.
- `kubectl apply -f deployment.yaml` — Apply configuration from a YAML file.

> ✅ **Primary Responsibility:**  
Act as the **interface to interact and manage Kubernetes clusters** from your terminal or command prompt.

---

> ⚡ **Summary:**  
Each concept serves a unique role:
- **Minikube:** Sets up the Kubernetes cluster locally.
- **Kubectl:** Manages and interacts with the Kubernetes cluster via commands.

